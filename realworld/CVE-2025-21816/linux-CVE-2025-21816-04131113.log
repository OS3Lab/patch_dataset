2025-04-13 11:13:47,955 - backport - DEBUG - revised patch:
--- a/include/linux/hrtimer_defs.h
+++ b/include/linux/hrtimer_defs.h
@@ -125,6 +125,7 @@ struct hrtimer_cpu_base {
 	ktime_t				softirq_expires_next;
 	struct hrtimer			*softirq_next_timer;
 	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
+	call_single_data_t		csd;
 } ____cacheline_aligned;
 
 

2025-04-13 11:13:47,960 - backport - DEBUG - Applying patch /tmp/tmpc47yzs8a
2025-04-13 11:13:47,964 - backport - DEBUG - Context mismatch
2025-04-13 11:13:48,424 - backport - DEBUG - Hunk 0 can not be applied, using LLM to generate a fix


[1m> Entering new AgentExecutor chain...[0m


[1m> Entering new RunnableSequence chain...[0m


[1m> Entering new RunnableAssign<agent_scratchpad> chain...[0m


[1m> Entering new RunnableParallel<agent_scratchpad> chain...[0m


[1m> Entering new RunnableLambda chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m


[1m> Entering new ChatPromptTemplate chain...[0m

[1m> Finished chain.[0m


[1m> Entering new ToolsAgentOutputParser chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m
[32;1m[1;3m
Invoking: `git_history` with `{}`


[0m[36;1m[1;3m1a4729ecafc2 hrtimers: Move hrtimer base related definitions into hrtimer_defs.h

diff --git a/include/linux/hrtimer_defs.h b/include/linux/hrtimer_defs.h
--- a/include/linux/hrtimer_defs.h
+++ b/include/linux/hrtimer_defs.h
@@ -27,0 +123,6 @@
+	ktime_t				softirq_expires_next;
+	struct hrtimer			*softirq_next_timer;
+	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
+} ____cacheline_aligned;
+

You need to do the following analysis based on the information in the last commit:
Analyze the code logic of the context of the patch to be ported in this commit step by step.
If code logic already existed before this commit, the patch context can be assumed to remain in a similar location. Use `locate` and `viewcode` to check your results.
If code logic were added in this commit, then you need to `git_show` for further details.
[0m

[1m> Entering new RunnableSequence chain...[0m


[1m> Entering new RunnableAssign<agent_scratchpad> chain...[0m


[1m> Entering new RunnableParallel<agent_scratchpad> chain...[0m


[1m> Entering new RunnableLambda chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m


[1m> Entering new ChatPromptTemplate chain...[0m

[1m> Finished chain.[0m


[1m> Entering new ToolsAgentOutputParser chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m
[32;1m[1;3m
Invoking: `git_show` with `{}`


[0m[33;1m[1;3mcommit 1a4729ecafc239f922d0c758bab7be0038714e88
Author: Anna-Maria Behnsen <anna-maria@linutronix.de>
Date:   Tue Jan 23 17:46:55 2024 +0100

    hrtimers: Move hrtimer base related definitions into hrtimer_defs.h
    
    hrtimer base related struct definitions are part of hrtimers.h as it is
    required there. With this, also the struct documentation which is for core
    code internal use, is exposed into the general api.
    
    To prevent this, move all core internal definitions and the related
    includes into hrtimer_defs.h.
    
    Signed-off-by: Anna-Maria Behnsen <anna-maria@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20240123164702.55612-2-anna-maria@linutronix.de

 include/linux/hrtimer.h      | 103 -------------------------------------------
 include/linux/hrtimer_defs.h | 102 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 102 insertions(+), 103 deletions(-)
Because the commit's code change maybe too long, so I generate the abstract of the code change to show you how code changed in this commit.
Commit shows that the patch code in old version maybe in the file include/linux/hrtimer.h around line number 195 to 201. The code is below
	ktime_t				softirq_expires_next;
	struct hrtimer			*softirq_next_timer;
	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
} ____cacheline_aligned;

static inline void hrtimer_set_expires(struct hrtimer *timer, ktime_t time)
You can call `viewcode` and `locate_symbol` to find the relevant code based on this information step by step.[0m

[1m> Entering new RunnableSequence chain...[0m


[1m> Entering new RunnableAssign<agent_scratchpad> chain...[0m


[1m> Entering new RunnableParallel<agent_scratchpad> chain...[0m


[1m> Entering new RunnableLambda chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m


[1m> Entering new ChatPromptTemplate chain...[0m

[1m> Finished chain.[0m


[1m> Entering new ToolsAgentOutputParser chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m
[32;1m[1;3m
Invoking: `locate_symbol` with `{'ref': '420102835862f49ec15c545594278dc5d2712f42', 'symbol': 'hrtimer_cpu_base'}`


[0m[33;1m[1;3minclude/linux/hrtimer.h:215[0m

[1m> Entering new RunnableSequence chain...[0m


[1m> Entering new RunnableAssign<agent_scratchpad> chain...[0m


[1m> Entering new RunnableParallel<agent_scratchpad> chain...[0m


[1m> Entering new RunnableLambda chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m


[1m> Entering new ChatPromptTemplate chain...[0m

[1m> Finished chain.[0m


[1m> Entering new ToolsAgentOutputParser chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m
[32;1m[1;3m
Invoking: `viewcode` with `{'ref': '420102835862f49ec15c545594278dc5d2712f42', 'path': 'include/linux/hrtimer.h', 'startline': 210, 'endline': 220}`


[0m[36;1m[1;3mHere are lines 210 through 220.

 *
 * Note: next_timer is just an optimization for __remove_hrtimer().
 *	 Do not dereference the pointer because it is not reliable on
 *	 cross cpu removals.
 */
struct hrtimer_cpu_base {
	raw_spinlock_t			lock;
	unsigned int			cpu;
	unsigned int			active_bases;
	unsigned int			clock_was_set_seq;
	unsigned int			hres_active		: 1,
Based on the previous information, think carefully do you see the target code? You may want to keep checking if you don't.
[0m

[1m> Entering new RunnableSequence chain...[0m


[1m> Entering new RunnableAssign<agent_scratchpad> chain...[0m


[1m> Entering new RunnableParallel<agent_scratchpad> chain...[0m


[1m> Entering new RunnableLambda chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m


[1m> Entering new ChatPromptTemplate chain...[0m

[1m> Finished chain.[0m


[1m> Entering new ToolsAgentOutputParser chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m
[32;1m[1;3m
Invoking: `viewcode` with `{'ref': '420102835862f49ec15c545594278dc5d2712f42', 'path': 'include/linux/hrtimer.h', 'startline': 200, 'endline': 230}`


[0m[36;1m[1;3mHere are lines 200 through 230.

 * @online:		CPU is online from an hrtimers point of view
 * @timer_waiters:	A hrtimer_cancel() invocation waits for the timer
 *			callback to finish.
 * @expires_next:	absolute time of the next event, is required for remote
 *			hrtimer enqueue; it is the total first expiry time (hard
 *			and soft hrtimer are taken into account)
 * @next_timer:		Pointer to the first expiring timer
 * @softirq_expires_next: Time to check, if soft queues needs also to be expired
 * @softirq_next_timer: Pointer to the first expiring softirq based timer
 * @clock_base:		array of clock bases for this cpu
 *
 * Note: next_timer is just an optimization for __remove_hrtimer().
 *	 Do not dereference the pointer because it is not reliable on
 *	 cross cpu removals.
 */
struct hrtimer_cpu_base {
	raw_spinlock_t			lock;
	unsigned int			cpu;
	unsigned int			active_bases;
	unsigned int			clock_was_set_seq;
	unsigned int			hres_active		: 1,
					in_hrtirq		: 1,
					hang_detected		: 1,
					softirq_activated       : 1,
					online			: 1;
#ifdef CONFIG_HIGH_RES_TIMERS
	unsigned int			nr_events;
	unsigned short			nr_retries;
	unsigned short			nr_hangs;
	unsigned int			max_hang_time;
#endif
Based on the previous information, think carefully do you see the target code? You may want to keep checking if you don't.
[0m

[1m> Entering new RunnableSequence chain...[0m


[1m> Entering new RunnableAssign<agent_scratchpad> chain...[0m


[1m> Entering new RunnableParallel<agent_scratchpad> chain...[0m


[1m> Entering new RunnableLambda chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m


[1m> Entering new ChatPromptTemplate chain...[0m

[1m> Finished chain.[0m


[1m> Entering new ToolsAgentOutputParser chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m
[32;1m[1;3m
Invoking: `viewcode` with `{'ref': '420102835862f49ec15c545594278dc5d2712f42', 'path': 'include/linux/hrtimer.h', 'startline': 230, 'endline': 240}`


[0m[36;1m[1;3mHere are lines 230 through 240.

#endif
#ifdef CONFIG_PREEMPT_RT
	spinlock_t			softirq_expiry_lock;
	atomic_t			timer_waiters;
#endif
	ktime_t				expires_next;
	struct hrtimer			*next_timer;
	ktime_t				softirq_expires_next;
	struct hrtimer			*softirq_next_timer;
	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
} ____cacheline_aligned;
Based on the previous information, think carefully do you see the target code? You may want to keep checking if you don't.
[0m

[1m> Entering new RunnableSequence chain...[0m


[1m> Entering new RunnableAssign<agent_scratchpad> chain...[0m


[1m> Entering new RunnableParallel<agent_scratchpad> chain...[0m


[1m> Entering new RunnableLambda chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m


[1m> Entering new ChatPromptTemplate chain...[0m

[1m> Finished chain.[0m


[1m> Entering new ToolsAgentOutputParser chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m
[32;1m[1;3m
Invoking: `validate` with `{'ref': '420102835862f49ec15c545594278dc5d2712f42', 'patch': '--- a/include/linux/hrtimer.h\n+++ b/include/linux/hrtimer.h\n@@ -236,6 +236,7 @@ struct hrtimer_cpu_base {\n \tktime_t\t\t\t\tsoftirq_expires_next;\n \tstruct hrtimer\t\t\t*softirq_next_timer;\n \tstruct hrtimer_clock_base\tclock_base[HRTIMER_MAX_CLOCK_BASES];\n+\tcall_single_data_t\t\tcsd;\n } ____cacheline_aligned;'}`
responded: The target code in the older version (`420102835862f49ec15c545594278dc5d2712f42`) is located in `include/linux/hrtimer.h` (lines 230-240). The relevant code snippet is:

```c
#ifdef CONFIG_PREEMPT_RT
	spinlock_t			softirq_expiry_lock;
	atomic_t			timer_waiters;
#endif
	ktime_t				expires_next;
	struct hrtimer			*next_timer;
	ktime_t				softirq_expires_next;
	struct hrtimer			*softirq_next_timer;
	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
} ____cacheline_aligned;
```

The patch in the newer version (`27af31e44949fa85550176520ef7086a0d00fd7b`) adds a `call_single_data_t` field (`csd`) to the `hrtimer_cpu_base` struct. 

### Patch Generation:
To backport this change, we need to add the `csd` field to the `hrtimer_cpu_base` struct in the older version. The context lines (lines 230-240) are present in the older version, so we can directly apply the patch.

Here is the generated patch:

```diff
--- a/include/linux/hrtimer.h
+++ b/include/linux/hrtimer.h
@@ -236,6 +236,7 @@ struct hrtimer_cpu_base {
 	ktime_t				softirq_expires_next;
 	struct hrtimer			*softirq_next_timer;
 	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
+	call_single_data_t		csd;
 } ____cacheline_aligned;
```

### Validation:
Now, I will validate this patch on the older version (`420102835862f49ec15c545594278dc5d2712f42`).

[0m2025-04-13 11:16:09,327 - backport - DEBUG - revised patch:
--- a/include/linux/hrtimer.h
+++ b/include/linux/hrtimer.h
@@ -236,4 +236,5 @@ struct hrtimer_cpu_base {
 	ktime_t				softirq_expires_next;
 	struct hrtimer			*softirq_next_timer;
 	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
+	call_single_data_t		csd;
 } ____cacheline_aligned;

2025-04-13 11:16:09,334 - backport - DEBUG - Applying patch /tmp/tmpu05y020e
[38;5;200m[1;3mPatch applied successfully
[0m

[1m> Entering new RunnableSequence chain...[0m


[1m> Entering new RunnableAssign<agent_scratchpad> chain...[0m


[1m> Entering new RunnableParallel<agent_scratchpad> chain...[0m


[1m> Entering new RunnableLambda chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m


[1m> Entering new ChatPromptTemplate chain...[0m

[1m> Finished chain.[0m


[1m> Entering new ToolsAgentOutputParser chain...[0m

[1m> Finished chain.[0m

[1m> Finished chain.[0m
[32;1m[1;3mThe patch has been successfully validated and can be applied to the older version (`420102835862f49ec15c545594278dc5d2712f42`) without conflicts. Here is the final patch:

```diff
--- a/include/linux/hrtimer.h
+++ b/include/linux/hrtimer.h
@@ -236,6 +236,7 @@ struct hrtimer_cpu_base {
 	ktime_t				softirq_expires_next;
 	struct hrtimer			*softirq_next_timer;
 	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
+	call_single_data_t		csd;
 } ____cacheline_aligned;
```

This patch adds the `csd` field to the `hrtimer_cpu_base` struct in the older version, matching the fix from the newer version. The patch is correct and ready for use.[0m

[1m> Finished chain.[0m
2025-04-13 11:16:23,246 - backport - DEBUG - revised patch:
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -58,6 +58,8 @@
 #define HRTIMER_ACTIVE_SOFT	(HRTIMER_ACTIVE_HARD << MASK_SHIFT)
 #define HRTIMER_ACTIVE_ALL	(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)
 
+static void retrigger_next_event(void *arg);
+
 /*
  * The timer bases:
  *

2025-04-13 11:16:23,250 - backport - DEBUG - Applying patch /tmp/tmppvcnpjrc
2025-04-13 11:16:23,644 - backport - DEBUG - Hunk 1 can be applied without any conflicts
2025-04-13 11:16:24,654 - backport - DEBUG - revised patch:
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -111,7 +113,8 @@ DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =
 			.clockid = CLOCK_TAI,
 			.get_time = &ktime_get_clocktai,
 		},
-	}
+	},
+	.csd = CSD_INIT(retrigger_next_event, NULL)
 };
 
 static const int hrtimer_clock_to_base_table[MAX_CLOCKS] = {

2025-04-13 11:16:24,658 - backport - DEBUG - Applying patch /tmp/tmpcbeom43d
2025-04-13 11:16:25,043 - backport - DEBUG - Hunk 2 can be applied without any conflicts
2025-04-13 11:16:25,983 - backport - DEBUG - revised patch:
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -124,6 +127,14 @@ static const int hrtimer_clock_to_base_table[MAX_CLOCKS] = {
 	[CLOCK_TAI]		= HRTIMER_BASE_TAI,
 };
 
+static inline bool hrtimer_base_is_online(struct hrtimer_cpu_base *base)
+{
+	if (!IS_ENABLED(CONFIG_HOTPLUG_CPU))
+		return true;
+	else
+		return likely(base->online);
+}
+
 /*
  * Functions and macros which are different for UP/SMP systems are kept in a
  * single place

2025-04-13 11:16:25,988 - backport - DEBUG - Applying patch /tmp/tmpsfrnuqwy
2025-04-13 11:16:26,375 - backport - DEBUG - Hunk 3 can be applied without any conflicts
2025-04-13 11:16:27,405 - backport - DEBUG - revised patch:
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -178,27 +189,54 @@ struct hrtimer_clock_base *lock_hrtimer_base(const struct hrtimer *timer,
 }
 
 /*
- * We do not migrate the timer when it is expiring before the next
- * event on the target cpu. When high resolution is enabled, we cannot
- * reprogram the target cpu hardware and we would cause it to fire
- * late. To keep it simple, we handle the high resolution enabled and
- * disabled case similar.
+ * Check if the elected target is suitable considering its next
+ * event and the hotplug state of the current CPU.
+ *
+ * If the elected target is remote and its next event is after the timer
+ * to queue, then a remote reprogram is necessary. However there is no
+ * guarantee the IPI handling the operation would arrive in time to meet
+ * the high resolution deadline. In this case the local CPU becomes a
+ * preferred target, unless it is offline.
+ *
+ * High and low resolution modes are handled the same way for simplicity.
  *
  * Called with cpu_base->lock of target cpu held.
  */
-static int
-hrtimer_check_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base)
+static bool hrtimer_suitable_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base,
+				    struct hrtimer_cpu_base *new_cpu_base,
+				    struct hrtimer_cpu_base *this_cpu_base)
 {
 	ktime_t expires;
 
+	/*
+	 * The local CPU clockevent can be reprogrammed. Also get_target_base()
+	 * guarantees it is online.
+	 */
+	if (new_cpu_base == this_cpu_base)
+		return true;
+
+	/*
+	 * The offline local CPU can't be the default target if the
+	 * next remote target event is after this timer. Keep the
+	 * elected new base. An IPI will we issued to reprogram
+	 * it as a last resort.
+	 */
+	if (!hrtimer_base_is_online(this_cpu_base))
+		return true;
+
 	expires = ktime_sub(hrtimer_get_expires(timer), new_base->offset);
-	return expires < new_base->cpu_base->expires_next;
+
+	return expires >= new_base->cpu_base->expires_next;
 }
 
-static inline
-struct hrtimer_cpu_base *get_target_base(struct hrtimer_cpu_base *base,
-					 int pinned)
+static inline struct hrtimer_cpu_base *get_target_base(struct hrtimer_cpu_base *base, int pinned)
 {
+	if (!hrtimer_base_is_online(base)) {
+		int cpu = cpumask_any_and(cpu_online_mask, housekeeping_cpumask(HK_TYPE_TIMER));
+
+		return &per_cpu(hrtimer_bases, cpu);
+	}
+
 #if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)
 	if (static_branch_likely(&timers_migration_enabled) && !pinned)
 		return &per_cpu(hrtimer_bases, get_nohz_timer_target());

2025-04-13 11:16:27,416 - backport - DEBUG - Applying patch /tmp/tmpxq8tqt9f
2025-04-13 11:16:27,805 - backport - DEBUG - Hunk 4 can be applied without any conflicts
2025-04-13 11:16:28,750 - backport - DEBUG - revised patch:
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -249,8 +287,8 @@ switch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,
 		raw_spin_unlock(&base->cpu_base->lock);
 		raw_spin_lock(&new_base->cpu_base->lock);
 
-		if (new_cpu_base != this_cpu_base &&
-		    hrtimer_check_target(timer, new_base)) {
+		if (!hrtimer_suitable_target(timer, new_base, new_cpu_base,
+					     this_cpu_base)) {
 			raw_spin_unlock(&new_base->cpu_base->lock);
 			raw_spin_lock(&base->cpu_base->lock);
 			new_cpu_base = this_cpu_base;

2025-04-13 11:16:28,754 - backport - DEBUG - Applying patch /tmp/tmpg02gfcvu
2025-04-13 11:16:29,128 - backport - DEBUG - Hunk 5 can be applied without any conflicts
2025-04-13 11:16:30,003 - backport - DEBUG - revised patch:
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -259,8 +297,7 @@ switch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,
 		}
 		WRITE_ONCE(timer->base, new_base);
 	} else {
-		if (new_cpu_base != this_cpu_base &&
-		    hrtimer_check_target(timer, new_base)) {
+		if (!hrtimer_suitable_target(timer, new_base,  new_cpu_base, this_cpu_base)) {
 			new_cpu_base = this_cpu_base;
 			goto again;
 		}

2025-04-13 11:16:30,007 - backport - DEBUG - Applying patch /tmp/tmp0k3b40z5
2025-04-13 11:16:30,382 - backport - DEBUG - Hunk 6 can be applied without any conflicts
2025-04-13 11:16:31,281 - backport - DEBUG - revised patch:
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -706,8 +743,6 @@ static inline int hrtimer_is_hres_enabled(void)
 	return hrtimer_hres_enabled;
 }
 
-static void retrigger_next_event(void *arg);
-
 /*
  * Switch to high resolution mode
  */

2025-04-13 11:16:31,284 - backport - DEBUG - Applying patch /tmp/tmp6loxjfdx
2025-04-13 11:16:31,654 - backport - DEBUG - Hunk 7 can be applied without any conflicts
2025-04-13 11:16:32,580 - backport - DEBUG - revised patch:
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -1195,6 +1230,7 @@ static int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
 				    u64 delta_ns, const enum hrtimer_mode mode,
 				    struct hrtimer_clock_base *base)
 {
+	struct hrtimer_cpu_base *this_cpu_base = this_cpu_ptr(&hrtimer_bases);
 	struct hrtimer_clock_base *new_base;
 	bool force_local, first;
 

2025-04-13 11:16:32,584 - backport - DEBUG - Applying patch /tmp/tmp3wctp5sq
2025-04-13 11:16:32,971 - backport - DEBUG - Hunk 8 can be applied without any conflicts
2025-04-13 11:16:33,944 - backport - DEBUG - revised patch:
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -1206,9 +1242,15 @@ static int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
 	 * and enforce reprogramming after it is queued no matter whether
 	 * it is the new first expiring timer again or not.
 	 */
-	force_local = base->cpu_base == this_cpu_ptr(&hrtimer_bases);
+	force_local = base->cpu_base == this_cpu_base;
 	force_local &= base->cpu_base->next_timer == timer;
 
+	/*
+	 * Don't force local queuing if this enqueue happens on a unplugged
+	 * CPU after hrtimer_cpu_dying() has been invoked.
+	 */
+	force_local &= this_cpu_base->online;
+
 	/*
 	 * Remove an active timer from the queue. In case it is not queued
 	 * on the current CPU, make sure that remove_hrtimer() updates the

2025-04-13 11:16:33,948 - backport - DEBUG - Applying patch /tmp/tmpqt75a4wx
2025-04-13 11:16:34,321 - backport - DEBUG - Hunk 9 can be applied without any conflicts
2025-04-13 11:16:35,235 - backport - DEBUG - revised patch:
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -1238,8 +1280,27 @@ static int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
 	}
 
 	first = enqueue_hrtimer(timer, new_base, mode);
-	if (!force_local)
-		return first;
+	if (!force_local) {
+		/*
+		 * If the current CPU base is online, then the timer is
+		 * never queued on a remote CPU if it would be the first
+		 * expiring timer there.
+		 */
+		if (hrtimer_base_is_online(this_cpu_base))
+			return first;
+
+		/*
+		 * Timer was enqueued remote because the current base is
+		 * already offline. If the timer is the first to expire,
+		 * kick the remote CPU to reprogram the clock event.
+		 */
+		if (first) {
+			struct hrtimer_cpu_base *new_cpu_base = new_base->cpu_base;
+
+			smp_call_function_single_async(new_cpu_base->cpu, &new_cpu_base->csd);
+		}
+		return 0;
+	}
 
 	/*
 	 * Timer was forced to stay on the current CPU to avoid

2025-04-13 11:16:35,243 - backport - DEBUG - Applying patch /tmp/tmplvxkhykn
2025-04-13 11:16:35,642 - backport - DEBUG - Hunk 10 can be applied without any conflicts
2025-04-13 11:16:35,645 - backport - INFO - Aplly all hunks in the patch      PASS
2025-04-13 11:16:36,440 - backport - DEBUG - The completed patch file /tmp/tmppxfc1yos
2025-04-13 11:16:36,455 - backport - DEBUG - The joined patch hunk 0 could be applied successfully, file /tmp/tmp_rbp79qu
2025-04-13 11:16:36,481 - backport - DEBUG - The joined patch hunk 1 could be applied successfully, file /tmp/tmpt69g6ep7
2025-04-13 11:16:36,499 - backport - DEBUG - The joined patch hunk 2 could be applied successfully, file /tmp/tmpetysa_ih
2025-04-13 11:16:36,514 - backport - DEBUG - The joined patch hunk 3 could be applied successfully, file /tmp/tmpx2o3e1d7
2025-04-13 11:16:36,614 - backport - DEBUG - The joined patch hunk 4 could be applied successfully, file /tmp/tmp6dc1rq1y
2025-04-13 11:16:36,639 - backport - DEBUG - The joined patch hunk 5 could be applied successfully, file /tmp/tmpocvbu3z3
2025-04-13 11:16:36,682 - backport - DEBUG - The joined patch hunk 6 could be applied successfully, file /tmp/tmp75t7u7u6
2025-04-13 11:16:36,713 - backport - DEBUG - The joined patch hunk 7 could be applied successfully, file /tmp/tmp1ld1kpo4
2025-04-13 11:16:36,733 - backport - DEBUG - The joined patch hunk 8 could be applied successfully, file /tmp/tmpz8vs61e6
2025-04-13 11:16:36,760 - backport - DEBUG - The joined patch hunk 9 could be applied successfully, file /tmp/tmpbatss31o
2025-04-13 11:16:36,778 - backport - DEBUG - The joined patch hunk 10 could be applied successfully, file /tmp/tmp_3or11kz
2025-04-13 11:16:36,779 - backport - DEBUG - Start compile the patched source code
2025-04-13 11:16:47,246 - backport - INFO - Compilation                       PASS
2025-04-13 11:16:47,249 - backport - DEBUG - Run testcase after compile
2025-04-13 11:16:47,252 - backport - DEBUG - No test.sh file found, considered as test passed.
2025-04-13 11:16:47,254 - backport - DEBUG - Run PoC after compile and run testcase
2025-04-13 11:16:47,257 - backport - DEBUG - No poc.sh file found, considered as PoC passed.
2025-04-13 11:16:47,260 - backport - INFO - Successfully backport the patch to the target release 420102835862f49ec15c545594278dc5d2712f42
2025-04-13 11:16:47,262 - backport - INFO - --- a/include/linux/hrtimer.h
+++ b/include/linux/hrtimer.h
@@ -236,4 +236,5 @@ struct hrtimer_cpu_base {
 	ktime_t				softirq_expires_next;
 	struct hrtimer			*softirq_next_timer;
 	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
+	call_single_data_t		csd;
 } ____cacheline_aligned;

--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -58,6 +58,8 @@
 #define HRTIMER_ACTIVE_SOFT	(HRTIMER_ACTIVE_HARD << MASK_SHIFT)
 #define HRTIMER_ACTIVE_ALL	(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)
 
+static void retrigger_next_event(void *arg);
+
 /*
  * The timer bases:
  *

--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -111,7 +113,8 @@ DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =
 			.clockid = CLOCK_TAI,
 			.get_time = &ktime_get_clocktai,
 		},
-	}
+	},
+	.csd = CSD_INIT(retrigger_next_event, NULL)
 };
 
 static const int hrtimer_clock_to_base_table[MAX_CLOCKS] = {

--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -124,6 +127,14 @@ static const int hrtimer_clock_to_base_table[MAX_CLOCKS] = {
 	[CLOCK_TAI]		= HRTIMER_BASE_TAI,
 };
 
+static inline bool hrtimer_base_is_online(struct hrtimer_cpu_base *base)
+{
+	if (!IS_ENABLED(CONFIG_HOTPLUG_CPU))
+		return true;
+	else
+		return likely(base->online);
+}
+
 /*
  * Functions and macros which are different for UP/SMP systems are kept in a
  * single place

--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -178,27 +189,54 @@ struct hrtimer_clock_base *lock_hrtimer_base(const struct hrtimer *timer,
 }
 
 /*
- * We do not migrate the timer when it is expiring before the next
- * event on the target cpu. When high resolution is enabled, we cannot
- * reprogram the target cpu hardware and we would cause it to fire
- * late. To keep it simple, we handle the high resolution enabled and
- * disabled case similar.
+ * Check if the elected target is suitable considering its next
+ * event and the hotplug state of the current CPU.
+ *
+ * If the elected target is remote and its next event is after the timer
+ * to queue, then a remote reprogram is necessary. However there is no
+ * guarantee the IPI handling the operation would arrive in time to meet
+ * the high resolution deadline. In this case the local CPU becomes a
+ * preferred target, unless it is offline.
+ *
+ * High and low resolution modes are handled the same way for simplicity.
  *
  * Called with cpu_base->lock of target cpu held.
  */
-static int
-hrtimer_check_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base)
+static bool hrtimer_suitable_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base,
+				    struct hrtimer_cpu_base *new_cpu_base,
+				    struct hrtimer_cpu_base *this_cpu_base)
 {
 	ktime_t expires;
 
+	/*
+	 * The local CPU clockevent can be reprogrammed. Also get_target_base()
+	 * guarantees it is online.
+	 */
+	if (new_cpu_base == this_cpu_base)
+		return true;
+
+	/*
+	 * The offline local CPU can't be the default target if the
+	 * next remote target event is after this timer. Keep the
+	 * elected new base. An IPI will we issued to reprogram
+	 * it as a last resort.
+	 */
+	if (!hrtimer_base_is_online(this_cpu_base))
+		return true;
+
 	expires = ktime_sub(hrtimer_get_expires(timer), new_base->offset);
-	return expires < new_base->cpu_base->expires_next;
+
+	return expires >= new_base->cpu_base->expires_next;
 }
 
-static inline
-struct hrtimer_cpu_base *get_target_base(struct hrtimer_cpu_base *base,
-					 int pinned)
+static inline struct hrtimer_cpu_base *get_target_base(struct hrtimer_cpu_base *base, int pinned)
 {
+	if (!hrtimer_base_is_online(base)) {
+		int cpu = cpumask_any_and(cpu_online_mask, housekeeping_cpumask(HK_TYPE_TIMER));
+
+		return &per_cpu(hrtimer_bases, cpu);
+	}
+
 #if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)
 	if (static_branch_likely(&timers_migration_enabled) && !pinned)
 		return &per_cpu(hrtimer_bases, get_nohz_timer_target());

--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -249,8 +287,8 @@ switch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,
 		raw_spin_unlock(&base->cpu_base->lock);
 		raw_spin_lock(&new_base->cpu_base->lock);
 
-		if (new_cpu_base != this_cpu_base &&
-		    hrtimer_check_target(timer, new_base)) {
+		if (!hrtimer_suitable_target(timer, new_base, new_cpu_base,
+					     this_cpu_base)) {
 			raw_spin_unlock(&new_base->cpu_base->lock);
 			raw_spin_lock(&base->cpu_base->lock);
 			new_cpu_base = this_cpu_base;

--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -259,8 +297,7 @@ switch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,
 		}
 		WRITE_ONCE(timer->base, new_base);
 	} else {
-		if (new_cpu_base != this_cpu_base &&
-		    hrtimer_check_target(timer, new_base)) {
+		if (!hrtimer_suitable_target(timer, new_base,  new_cpu_base, this_cpu_base)) {
 			new_cpu_base = this_cpu_base;
 			goto again;
 		}

--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -706,8 +743,6 @@ static inline int hrtimer_is_hres_enabled(void)
 	return hrtimer_hres_enabled;
 }
 
-static void retrigger_next_event(void *arg);
-
 /*
  * Switch to high resolution mode
  */

--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -1195,6 +1230,7 @@ static int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
 				    u64 delta_ns, const enum hrtimer_mode mode,
 				    struct hrtimer_clock_base *base)
 {
+	struct hrtimer_cpu_base *this_cpu_base = this_cpu_ptr(&hrtimer_bases);
 	struct hrtimer_clock_base *new_base;
 	bool force_local, first;
 

--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -1206,9 +1242,15 @@ static int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
 	 * and enforce reprogramming after it is queued no matter whether
 	 * it is the new first expiring timer again or not.
 	 */
-	force_local = base->cpu_base == this_cpu_ptr(&hrtimer_bases);
+	force_local = base->cpu_base == this_cpu_base;
 	force_local &= base->cpu_base->next_timer == timer;
 
+	/*
+	 * Don't force local queuing if this enqueue happens on a unplugged
+	 * CPU after hrtimer_cpu_dying() has been invoked.
+	 */
+	force_local &= this_cpu_base->online;
+
 	/*
 	 * Remove an active timer from the queue. In case it is not queued
 	 * on the current CPU, make sure that remove_hrtimer() updates the

--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -1238,8 +1280,27 @@ static int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
 	}
 
 	first = enqueue_hrtimer(timer, new_base, mode);
-	if (!force_local)
-		return first;
+	if (!force_local) {
+		/*
+		 * If the current CPU base is online, then the timer is
+		 * never queued on a remote CPU if it would be the first
+		 * expiring timer there.
+		 */
+		if (hrtimer_base_is_online(this_cpu_base))
+			return first;
+
+		/*
+		 * Timer was enqueued remote because the current base is
+		 * already offline. If the timer is the first to expire,
+		 * kick the remote CPU to reprogram the clock event.
+		 */
+		if (first) {
+			struct hrtimer_cpu_base *new_cpu_base = new_base->cpu_base;
+
+			smp_call_function_single_async(new_cpu_base->cpu, &new_cpu_base->csd);
+		}
+		return 0;
+	}
 
 	/*
 	 * Timer was forced to stay on the current CPU to avoid

2025-04-13 11:16:58,982 - backport - DEBUG - This patch total cost: $0.00
2025-04-13 11:16:58,985 - backport - DEBUG - This patch total consume tokens: 0.0(k)
2025-04-13 11:16:58,988 - backport - DEBUG - This patch total cost time: 182 Seconds.
