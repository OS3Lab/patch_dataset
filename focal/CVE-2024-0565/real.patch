commit b56e900b826cbacb1c76bd38c5c6e36d5245c73c
Author: Paulo Alcantara <pc@manguebit.com>
Date:   Mon Jan 29 22:49:00 2024 +0100

    smb: client: fix OOB in receive_encrypted_standard()
    
    Fix potential OOB in receive_encrypted_standard() if server returned a
    large shdr->NextCommand that would end up writing off the end of
    @next_buffer.
    
    Fixes: b24df3e30cbf ("cifs: update receive_encrypted_standard to handle compounded responses")
    Cc: stable@vger.kernel.org
    Reported-by: Robert Morris <rtm@csail.mit.edu>
    Signed-off-by: Paulo Alcantara (SUSE) <pc@manguebit.com>
    Signed-off-by: Steve French <stfrench@microsoft.com>
    
    CVE-2024-0565
    (backported from commit eec04ea119691e65227a97ce53c0da6b9b74b0b7)
    [yuxuan.luo: There exists a prerequisite commit 0d35e382e4e9 (“cifs:
     Create a new shared file holding smb2 pdu definitions“). Although the
     bottom half of the struct smb2_sync_hdr definition has been modified,
     this CVE relevant part remains untouched. It is acceptable to skip this
     patch and ignore the struct conflict.]
    Signed-off-by: Yuxuan Luo <yuxuan.luo@canonical.com>
    Acked-by: Stefan Bader <stefan.bader@canonical.com>
    Acked-by: Roxana Nicolescu <roxana.nicolescu@canonical.com>
    Acked-by: Andrei Gherzan <andrei.gherzan@canonical.com>
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c
index df200497aa5b..bacbe8eaebfb 100644
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@ -4381,6 +4381,7 @@ receive_encrypted_standard(struct TCP_Server_Info *server,
 	struct smb2_sync_hdr *shdr;
 	unsigned int pdu_length = server->pdu_size;
 	unsigned int buf_size;
+	unsigned int next_cmd;
 	struct mid_q_entry *mid_entry;
 	int next_is_large;
 	char *next_buffer = NULL;
@@ -4409,14 +4410,15 @@ receive_encrypted_standard(struct TCP_Server_Info *server,
 	next_is_large = server->large_buf;
 one_more:
 	shdr = (struct smb2_sync_hdr *)buf;
-	if (shdr->NextCommand) {
+	next_cmd = le32_to_cpu(shdr->NextCommand);
+	if (next_cmd) {
+		if (WARN_ON_ONCE(next_cmd > pdu_length))
+			return -1;
 		if (next_is_large)
 			next_buffer = (char *)cifs_buf_get();
 		else
 			next_buffer = (char *)cifs_small_buf_get();
-		memcpy(next_buffer,
-		       buf + le32_to_cpu(shdr->NextCommand),
-		       pdu_length - le32_to_cpu(shdr->NextCommand));
+		memcpy(next_buffer, buf + next_cmd, pdu_length - next_cmd);
 	}
 
 	mid_entry = smb2_find_mid(server, buf);
@@ -4440,8 +4442,8 @@ receive_encrypted_standard(struct TCP_Server_Info *server,
 	else
 		ret = cifs_handle_standard(server, mid_entry);
 
-	if (ret == 0 && shdr->NextCommand) {
-		pdu_length -= le32_to_cpu(shdr->NextCommand);
+	if (ret == 0 && next_cmd) {
+		pdu_length -= next_cmd;
 		server->large_buf = next_is_large;
 		if (next_is_large)
 			server->bigbuf = buf = next_buffer;
