From 6e0399c549c31ef49fbe34ac1a1a7706c8eab25a Mon Sep 17 00:00:00 2001
From: Gui-Dong Han <2045gemini@gmail.com>
Date: Fri, 22 Dec 2023 23:12:41 +0800
Subject: [B][PATCH 1/1] Bluetooth: Fix atomicity violation in
 {min,max}_key_size_set

In min_key_size_set():
    if (val > hdev->le_max_key_size || val < SMP_MIN_ENC_KEY_SIZE)
        return -EINVAL;
    hci_dev_lock(hdev);
    hdev->le_min_key_size = val;
    hci_dev_unlock(hdev);

In max_key_size_set():
    if (val > SMP_MAX_ENC_KEY_SIZE || val < hdev->le_min_key_size)
        return -EINVAL;
    hci_dev_lock(hdev);
    hdev->le_max_key_size = val;
    hci_dev_unlock(hdev);

The atomicity violation occurs due to concurrent execution of set_min and
set_max funcs.Consider a scenario where setmin writes a new, valid 'min'
value, and concurrently, setmax writes a value that is greater than the
old 'min' but smaller than the new 'min'. In this case, setmax might check
against the old 'min' value (before acquiring the lock) but write its
value after the 'min' has been updated by setmin. This leads to a
situation where the 'max' value ends up being smaller than the 'min'
value, which is an inconsistency.

This possible bug is found by an experimental static analysis tool
developed by our team, BassCheck[1]. This tool analyzes the locking APIs
to extract function pairs that can be concurrently executed, and then
analyzes the instructions in the paired functions to identify possible
concurrency bugs including data races and atomicity violations. The above
possible bug is reported when our tool analyzes the source code of
Linux 5.17.

To resolve this issue, it is suggested to encompass the validity checks
within the locked sections in both set_min and set_max funcs. The
modification ensures that the validation of 'val' against the
current min/max values is atomic, thus maintaining the integrity of the
settings. With this patch applied, our tool no longer reports the bug,
with the kernel configuration allyesconfig for x86_64. Due to the lack of
associated hardware, we cannot test the patch in runtime testing, and just
verify it according to the code logic.

[1] https://sites.google.com/view/basscheck/

Fixes: 18f81241b74f ("Bluetooth: Move {min,max}_key_size debugfs ...")
Cc: stable@vger.kernel.org
Signed-off-by: Gui-Dong Han <2045gemini@gmail.com>
Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
(backported from commit da9065caa594d19b26e1a030fd0cc27bd365d685)
[yuxuan.luo:
Although the break commit is not included in the tree, we believe that
the race condition has long existed since the introduction of
le_min_key_size_write() and le_max_key_size_write() which were later
renamed to {min,max}_key_size_set(). Therefore, I manually applied the
fix made for hci_debugfs.c to smp.c since 18f81241b74f ("Bluetooth: Move
{min,max}_key_size debugfs into hci_debugfs_create_le") is yet to be
introduced.
]
CVE-2024-24860
Signed-off-by: Yuxuan Luo <yuxuan.luo@canonical.com>
---
 net/bluetooth/smp.c | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/net/bluetooth/smp.c b/net/bluetooth/smp.c
index 4d5ba9778885d..2b0163abd2cfb 100644
--- a/net/bluetooth/smp.c
+++ b/net/bluetooth/smp.c
@@ -3398,11 +3398,15 @@ static ssize_t le_min_key_size_write(struct file *file,
 
 	sscanf(buf, "%hhu", &key_size);
 
+	hci_dev_lock(hdev);
 	if (key_size > hdev->le_max_key_size ||
-	    key_size < SMP_MIN_ENC_KEY_SIZE)
+	    key_size < SMP_MIN_ENC_KEY_SIZE) {
+		hci_dev_unlock(hdev);
 		return -EINVAL;
+	}
 
 	hdev->le_min_key_size = key_size;
+	hci_dev_unlock(hdev);
 
 	return count;
 }
@@ -3442,11 +3446,15 @@ static ssize_t le_max_key_size_write(struct file *file,
 
 	sscanf(buf, "%hhu", &key_size);
 
+	hci_dev_lock(hdev);
 	if (key_size > SMP_MAX_ENC_KEY_SIZE ||
-	    key_size < hdev->le_min_key_size)
+	    key_size < hdev->le_min_key_size) {
+		hci_dev_unlock(hdev);
 		return -EINVAL;
+	}
 
 	hdev->le_max_key_size = key_size;
+	hci_dev_unlock(hdev);
 
 	return count;
 }
-- 
2.34.1

